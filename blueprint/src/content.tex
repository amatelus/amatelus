% AMATELUS Protocol Blueprint
% English specification based on formal verification and architectural analysis

\chapter{Nomenclature and Scope}

\section{Terminology}

This document uses two complementary names for the same underlying technology:

\subsection{AMT Protocol (Technical Name)}

\textbf{AMT} (Autonomous Meta-Trust) is the \emph{technical name} for the protocol, designed for international standardization. This is the name used in technical discussions, standards bodies, and peer-reviewed literature.

\subsection{AMATELUS (Marketing Name)}

\textbf{AMATELUS} is the \emph{marketing name}, indicating "Japanese origin." This is used for brand identity, commercial deployment, and public communication in Japan.

\subsection{Relationship}

\begin{itemize}
  \item \textbf{AMT Protocol} = international-standard-oriented technical specification
  \item \textbf{AMATELUS} = Japan-specific implementation and deployment brand
  \item Both refer to the same underlying cryptographic authentication mechanism
\end{itemize}

\section{Document Scope}

This blueprint covers:
\begin{itemize}
  \item The AMT Protocol (technical foundation)
  \item The did:amt DID Method Specification (standardized identifier format)
  \item AMATELUS implementation guidance (Japan-specific deployment)
  \item Cryptographic foundations and formal proofs
\end{itemize}

\chapter{Introduction}

\section{AMATELUS Protocol Overview}

The AMATELUS protocol is a cryptographic authentication mechanism integrating Decentralized Identifiers (DIDs), Verifiable Credentials (VCs), and Zero-Knowledge Proofs (ZKPs).

\subsection{What AMATELUS Provides}

AMATELUS delivers the following capabilities:
\begin{itemize}
  \item Public key infrastructure (PKI) based distributed identifiers
  \item Zero-knowledge proof-based attribute ownership verification
  \item Verifiable credentials for claim issuance and storage
  \item Cryptographic trust guarantees
\end{itemize}

\subsection{What AMATELUS Does NOT Provide}

Critically, AMATELUS \emph{does not} provide:
\begin{itemize}
  \item Centralized directory services (DID resolution is local-only)
  \item Mediation or relay infrastructure
  \item User authorization decisions
  \item Communication endpoint management
  \item Message delivery guarantees
\end{itemize}

\subsection{Design Philosophy}

AMATELUS is a \emph{cryptographic authentication mechanism}, not a communication infrastructure.

The core design principle emerges from the observation that:
\begin{itemize}
  \item Every real-world service (banking, government, voting, SNS) requires a centralized service provider
  \item AMATELUS provides only cryptographic trust verification
  \item Service providers maintain responsibility for endpoints, authorization, and communication security
  \item Individual users bear zero burden for endpoint contract management
\end{itemize}

This boundary-clarity eliminates the complexity of distributed infrastructure while preserving cryptographic security properties.

\chapter{did:amt Method Specification}

\section{Abstract}

The \texttt{did:amt} method specifies a Decentralized Identifier (DID) that is algorithmically generated and resolved without reliance on any external Verifiable Data Registry (VDR) such as a blockchain. This method is based on the AMT (Autonomous Meta-Trust) Protocol, designed for high-stakes environments like public administration, where data integrity and operational robustness are paramount.

\section{did:amt Syntax}

The \texttt{did:amt} syntax conforms to the W3C DID Core specification:

\begin{verbatim}
did-amt              := "did:amt:" method-specific-id
method-specific-id   := crockford-base32-encoded-sha3-512-hash
\end{verbatim}

The \texttt{method-specific-id} is a Crockford's Base32 encoded string of the hash value generated through the local creation process.

\subsection{Crockford's Base32 Character Set}

\texttt{0123456789ABCDEFGHJKMNPQRSTVWXYZ}

This character set is chosen to minimize human transcription errors in administrative settings (e.g., avoiding confusion between \texttt{O} and \texttt{0}, or \texttt{I} and \texttt{l}).

\section{CRUD Operations}

\subsection{Create: Local Generation}

A \texttt{did:amt} identifier is generated locally on the owner's device. No network registration is required.

\begin{enumerate}
  \item Generate Ed25519 key pair
  \item Prepare information pair: AMT Version Number + Public Key
  \item Select DID Document template corresponding to AMT version
  \item Derive DID:
    \begin{enumerate}
      \item Encode Ed25519 public key in Crockford's Base32 with multibase prefix \texttt{k}
      \item Insert into DID Document template
      \item Normalize template using JCS (RFC 8785)
      \item Hash with SHA3-512
      \item Encode hash digest with Crockford's Base32
      \item Prepend \texttt{did:amt:} to obtain final DID
    \end{enumerate}
  \item Finalize DID Document with derived DID
\end{enumerate}

\subsection{Read: Local Resolution}

The resolution of a \texttt{did:amt} is completed locally by a verifier who receives the \texttt{[AMT Version Number, Public Key]} pair from the owner and executes the same derivation steps.

No external service calls required.

\subsection{Update: Not Supported}

As \texttt{did:amt} DID Documents are immutable, Update operations are not supported. Key rotation is handled by issuing a new DID and linking it via a ``DID Continuity Verifiable Credential'' issued by a trusted third party.

\subsection{Deactivate: Key Destruction}

There is no explicit Deactivate operation. Deactivation is effectively achieved by destroying the associated private key.

\section{Cryptographic Properties}

\subsection{DID Identifier Security}

\begin{itemize}
  \item \textbf{Hash function}: SHA3-512 (post-quantum collision resistance)
  \item \textbf{Security level}: 256-bit (quantum-resistant)
  \item \textbf{Uniqueness}: Permanent uniqueness guaranteed by collision resistance
\end{itemize}

\subsection{DID Ownership Proof}

\begin{itemize}
  \item \textbf{Signature algorithm}: Ed25519 (current version)
  \item \textbf{Security level}: 128-bit (classical only, see future evolution)
  \item \textbf{Signature verification}: Public key validation against DID Document
\end{itemize}

\subsection{Privacy}

The avoidance of a Verifiable Data Registry (VDR) ensures that:
\begin{itemize}
  \item DIDs are not publicly enumerable
  \item No central authority records DID creation
  \item High degree of privacy maintained
\end{itemize}

\subsection{Operational Robustness}

Crockford's Base32 encoding minimizes human transcription errors during manual entry in administrative processes.

\section{Future Evolution: PQC Transition}

\subsection{Versioning for Cryptographic Agility}

The AMT protocol is designed with ``cryptographic agility,'' allowing for the upgrade of its cryptographic suite through versioning.

\subsection{Foreseeable Changes (AMT v1+)}

\subsubsection{Post-Quantum Signature Migration}

The most critical change will be migration from Ed25519 to a NIST-selected PQC signature algorithm (e.g., CRYSTALS-Dilithium). This ensures DID ownership proof is also secure against quantum computers.

\subsubsection{Binary Data Format Challenge}

PQC signature algorithms require significantly larger public key and signature sizes (several to tens of kilobytes). Future versions will likely specify a binary representation format such as CBOR (Concise Binary Object Representation) for DID Documents to maintain efficiency.

\subsubsection{Interoperability Through Versioning}

The \texttt{AMT Version Number} presented by the owner allows verifiers to accurately determine:
\begin{itemize}
  \item Which cryptographic algorithms to use (Ed25519 vs PQC)
  \item Which data formats to expect (JSON-LD vs CBOR)
  \item Secure interoperability during transition periods
\end{itemize}

\subsection{Example: Version 0 DID Document}

\begin{verbatim}
{
  "@context": ["https://www.w3.org/ns/did/v1"],
  "id": "did:amt:0V3R4T7K1Q2P3N4M5J6H7G8F5D4C3B2A...",
  "verificationMethod": [{
    "id": "did:amt:0V3R4T7K1Q2P3N4M5J6H7G8F5D4C3B2A...#key-1",
    "type": "Ed25519VerificationKey2020",
    "controller": "did:amt:0V3R4T7K1Q2P3N4M5J6H7G8F5D4C3B2A...",
    "publicKeyMultibase": "k3t635r7r1c0kdf41n2p5h3t2d3n2g5r..."
  }],
  "authentication": ["#key-1"],
  "assertionMethod": ["#key-1"]
}
\end{verbatim}

\chapter{Deployment Models}

\section{Service-Driven Model (Primary)}

In the predominant deployment model:
\begin{enumerate}
  \item Service provider application (bank, government, SNS) initiates
  \item Wallet is invoked from service app via OS-level Intent/deeplink
  \item Wallet generates DIDComm message containing:
    \begin{itemize}
      \item Communication DID (ephemeral or persistent based on service)
      \item DID Document (public key only)
      \item VC/ZKP proving required attributes
    \end{itemize}
  \item DIDComm message sent to service provider (HTTPS, typically)
  \item Service provider performs:
    \begin{itemize}
      \item Cryptographic verification of ZKP/VC
      \item Authorization decision
      \item Service execution
    \end{itemize}
\end{enumerate}

Trust origin: Service provider (centralized, established).

Endpoint lifecycle: Service-scoped (session-based).

\section{Physical Proximity Model (Supplementary)}

For in-person scenarios:
\begin{enumerate}
  \item Bluetooth Low Energy (BLE) provides discovery via physical proximity
  \item Public services (municipal offices, event gates)
  \item Session completes within local network
  \item No persistent endpoint contracts
\end{enumerate}

Examples:
\begin{itemize}
  \item Age verification at municipal counter
  \item Facility access control
  \item In-person credential verification
\end{itemize}

\chapter{Technical Specifications}

\section{DID Document Design Principles}

The AMT protocol employs did:amt for distributed identifier generation and resolution. The DID Document structure is minimal and stateless:

\begin{verbatim}
DID := did:amt:H(DIDDoc)

DIDDoc := {
  id: DID,
  publicKey: PublicKey,
  metadata: Metadata
}
\end{verbatim}

where $H$ is SHA3-512 (collision-resistant hash function).

\subsection{Critical Design Decision: Abolition of serviceEndpoint}

Traditional DID specifications include \texttt{serviceEndpoint} in DIDDocuments. The AMT protocol rejects this for principled reasons:

\subsubsection{Problem with serviceEndpoint}

\begin{itemize}
  \item \textbf{Short lifetime}: Service endpoint contracts last months to few years
  \item \textbf{Individual burden}: Users must manage contract renewals and provider changes
  \item \textbf{Unrealistic assumption}: Assumes individual can maintain stable, contracted endpoints
  \item \textbf{Real-world failure}: When provider fails or service terminates, users cannot migrate
\end{itemize}

\subsubsection{AMT Solution}

Remove \texttt{serviceEndpoint} from DIDDocument entirely.

Instead:
\begin{itemize}
  \item DID lifetime: Long-term (public-key-based, years to decades)
  \item Endpoint lifetime: Session-scoped (minutes to hours)
  \item Endpoint management: Service provider responsibility only
  \item Individual burden: Zero
\end{itemize}

\subsubsection{Implementation Reality}

\begin{itemize}
  \item Wallet is invoked by service app (already knows its own endpoint)
  \item DIDDocument contains only public key for cryptographic verification
  \item Endpoint information implicit in application context
  \item No distributed endpoint discovery needed
\end{itemize}

For complete did:amt specification details, see Chapter 2 (did:amt Method Specification).

\section{DIDComm Integration}

AMATELUS employs DIDComm Messaging v2.1 as the sole communication protocol.

\subsection{Message Structure}

\begin{verbatim}
DIDCommMessageSend := {
  senderDID: ValidDID,
  senderDoc: Option<ValidDIDDocument>,
  vcs: List<ValidVC>,
  zkp: Option<ValidZKP>
}
\end{verbatim}

\subsection{Security Properties}

\begin{itemize}
  \item \textbf{ECDH-1PU authenticated encryption}: Sender identity authenticated exclusively to recipient
  \item \textbf{Message-level security}: Independent of transport layer
  \item \textbf{Transport agnosticism}: Works over HTTPS, BLE, WebSocket, etc.
  \item \textbf{Sender anonymity (optional)}: Anoncrypt layer available if needed
\end{itemize}

\section{Verifiable Credentials}

\subsection{VC Structure}

\begin{verbatim}
VC := {
  issuer: DID_issuer,
  subject: DID_subject,
  claims: Claims,
  signature: Signature,
  credentialStatus: RevocationInfo,
  deLinkageInfo: Option<DeLinkageInfo>
}
\end{verbatim}

\subsection{Delinkage Information}

To prevent cross-service correlation:

\begin{verbatim}
DeLinkageInfo := {
  identityDID: DID,        // Long-term identity DID
  communicationDID: DID    // Session-specific DID
}
\end{verbatim}

ZKP proves ownership of both DIDs without revealing either to external parties.

\section{Zero-Knowledge Proofs}

\subsection{Dual Nonce Binding}

\begin{verbatim}
ZKP := (π, x, nonce_holder, nonce_verifier)
where π proves knowledge of w such that
R(x, w, nonce_holder, nonce_verifier) = 1
\end{verbatim}

\subsection{Nonce Generation and Binding}

Both Holder and Verifier generate independent nonces (≥128 bits):

\begin{enumerate}
  \item Verifier generates \texttt{nonce2} (challenge)
  \item Verifier sends \texttt{nonce2} to Holder
  \item Holder generates \texttt{nonce1} independently
  \item Holder combines: \texttt{nonce\_combined = H(nonce1 || nonce2)}
  \item ZKP bound to \texttt{nonce\_combined}
  \item Holder returns (ZKP, nonce1) to Verifier
  \item Verifier verifies both nonces cryptographically
\end{enumerate}

\subsection{Security Property: Mutual Defense}

If either party generates unique nonces:
\begin{itemize}
  \item Holder bug (fixed nonce1) $\Rightarrow$ Verifier's nonce2 provides protection
  \item Verifier bug (fixed nonce2) $\Rightarrow$ Holder's nonce1 provides protection
  \item Both unique $\Rightarrow$ Complete protection from replay
\end{itemize}

Neither party depends solely on the other's implementation quality.

\subsection{Computational Efficiency}

\begin{itemize}
  \item \textbf{Offline precomputation}: Heavy circuit evaluation (minutes to hours)
  \item \textbf{Real-time nonce binding}: Light operations only (milliseconds to hundreds of milliseconds)
  \item \textbf{UX compatibility}: User interaction completes within tolerance (3 seconds)
\end{itemize}

\chapter{Trust Architecture}

\section{Responsibility Boundaries}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Component} & \textbf{AMATELUS} & \textbf{Service Provider} \\
\hline
Public Key Infrastructure & \checkmark & -- \\
DID generation & \checkmark & -- \\
VC issuance/validation (1-layer) & \checkmark & Policy \\
ZKP generation/verification & \checkmark & -- \\
Endpoint management & -- & \checkmark \\
Message delivery & -- & \checkmark \\
Authorization decisions & -- & \checkmark \\
Communication security (TLS) & -- & \checkmark \\
\hline
\end{tabular}
\end{center}

\section{Trust Origin}

\begin{itemize}
  \item \textbf{Cryptographic trust}: Originating from AMATELUS protocol
  \item \textbf{Operational trust}: Originating from service provider (centralized)
  \item \textbf{Authorization trust}: Originating from service provider (centralized)
\end{itemize}

The separation prevents AMATELUS from assuming responsibilities it cannot scale to manage globally.

\section{One-Layer Trust Limitation}

AMATELUS validates only 1-layer VC chains:

\begin{itemize}
  \item \textbf{0-layer}: Direct issuance from trusted anchor
  \item \textbf{1-layer}: Delegated issuance (trustee validated against anchor)
  \item \textbf{2+ layers}: Explicitly \emph{not} validated by AMATELUS protocol
\end{itemize}

This prevents:
\begin{itemize}
  \item Delegation chain attacks
  \item Circular credential verification
  \item Unbounded revocation propagation
\end{itemize}

\chapter{Cryptographic Foundations}

\section{Security Assumptions}

\begin{itemize}
  \item \textbf{Collision-resistant hash}: SHA3-512 provides 128-bit security against quantum adversaries
  \item \textbf{Unforgeable signatures}: Dilithium2 provides 128-bit security against quantum adversaries
  \item \textbf{ZKP soundness}: Standard zero-knowledge properties (completeness, soundness, zero-knowledge)
  \item \textbf{Independent nonce generation}: Cryptographically random nonces with sufficient entropy
\end{itemize}

\section{Threat Model and Mitigations}

\subsection{Impersonation Attack (Different Secret Key)}

\begin{itemize}
  \item \textbf{Attack}: Attacker uses different secret key to forge ZKP
  \item \textbf{Defense}: DIDComm makes sender's public key known to recipient
  \item \textbf{Result}: Different secret key $\Rightarrow$ signature verification fails
  \item \textbf{Protocol layer}: Cryptographically prevented
\end{itemize}

\subsection{Replay Attack (Same ZKP, Same User)}

\begin{itemize}
  \item \textbf{Attack}: Legitimate user reuses identical ZKP in new session
  \item \textbf{Defense}: Dual nonce binding ensures each ZKP corresponds to unique nonce pair
  \item \textbf{Result}: Session-specific ZKP cannot be reused
  \item \textbf{Service layer}: Optional nonce history management (service responsibility)
\end{itemize}

\subsection{Man-in-the-Middle Attack}

\begin{itemize}
  \item \textbf{Attack}: Intermediary intercepts and modifies messages
  \item \textbf{Defense}: ECDH-1PU authenticated encryption (service provider responsibility)
  \item \textbf{Result}: Message authentication prevents undetected modification
  \item \textbf{Transport layer}: TLS/HTTPS (service provider responsibility)
\end{itemize}

\subsection{Sybil Attack (Multiple DIDs)}

\begin{itemize}
  \item \textbf{Attack}: Single entity controls multiple DIDs to gain asymmetric advantages
  \item \textbf{Protocol position}: Multiple DID possession is intentional design for privacy
  \item \textbf{Mitigation}: Anonymous Hash Identifier (AHI) restricts per-audit-domain abuse
  \item \textbf{Social layer}: Operational policy and service-specific restrictions
\end{itemize}

\chapter{Privacy Architecture}

\section{Anti-Linkability Across Services}

Multiple DIDs enable cross-service unlinkability:

\begin{verbatim}
∀ DID₁, DID₂, Service₁, Service₂:
  (Service₁ ≠ Service₂) ∧
  Link(DID₁, DID₂) requires 2^128 quantum operations
\end{verbatim}

\section{Zero-Knowledge Property}

ZKP reveal attribute ownership without revealing identity:

\begin{itemize}
  \item \textbf{Public}: Attribute claimed (age ≥ 18)
  \item \textbf{Hidden}: Identity proving the attribute
  \item \textbf{Hidden}: Secret key generating the proof
  \item \textbf{Verified}: ZKP authenticity via public key
\end{itemize}

\section{Deniable Authentication}

For privacy-sensitive scenarios, anonymous encryption (Anoncrypt) available:

\begin{itemize}
  \item Sender identity hidden from intermediaries
  \item Recipient verifies proof authenticity (still authenticated)
  \item Sender maintains plausible deniability
\end{itemize}

\chapter{Implementation Guidance}

\section{Wallet Implementation Requirements}

\subsection{Secret Key Management}

\begin{itemize}
  \item Store private keys in secure enclave (iOS/Android hardware)
  \item Never export unencrypted private keys
  \item Implement key derivation from user-memorizable seeds (BIP39 compatible)
\end{itemize}

\subsection{DID Lifecycle}

\subsubsection{Identity DIDs}

\begin{itemize}
  \item Generated once per credential lifetime (typically 1-10 years)
  \item Persisted across wallet updates and device changes
  \item Associated with formal credentials (passport, license, etc.)
\end{itemize}

\subsubsection{Communication DIDs}

\begin{itemize}
  \item Generated per service engagement or per session (configurable)
  \item Destroyed if VC not issued (one-time verification)
  \item Persisted if VC issued (login reuse case)
  \item Linked to counterparty DID in wallet for session continuation
\end{itemize}

\subsection{VC Storage}

\begin{itemize}
  \item Store issued VCs with \texttt{deLinkageInfo}
  \item Enable offline VC verification
  \item Implement selective disclosure (claim subset presentation)
  \item Track VC issuance context (service, timestamp, nonce)
\end{itemize}

\section{Service Provider Integration}

\subsection{DIDComm Endpoint Setup}

\begin{enumerate}
  \item Publish service endpoint URL (HTTPS with valid TLS)
  \item Accept POST requests with DIDComm messages
  \item Parse and cryptographically verify ZKP
  \item Execute service logic based on verified claims
  \item Return VC (if registration service) or result (if verification-only)
\end{enumerate}

\subsection{Authorization Decision Points}

Services must decide:

\begin{itemize}
  \item Which claims are required for service access
  \item Which DIDs are trusted for VC validation
  \item How to handle multiple DIDs from same user (user linking policy)
  \item Whether to issue persistent VC or one-time verification
\end{itemize}

\subsection{Nonce Management (Optional Service Feature)}

If replay prevention beyond DIDComm is required:

\begin{enumerate}
  \item Generate unique nonce per session
  \item Send nonce to wallet
  \item Verify returned ZKP includes nonce in cryptographic binding
  \item Record used nonces to prevent reuse
  \item Clean up nonce history based on session TTL
\end{enumerate}

Note: Nonce management is \emph{optional} at service layer, not protocol-required.

\section{Deployment Scenarios}

\subsection{One-Time Verification (Age Confirmation)}

\begin{itemize}
  \item Holder generates ephemeral communication DID
  \item Generates ZKP proving age ≥ 18
  \item Verifier validates ZKP, permits or denies access
  \item Communication DID destroyed (no VC issued)
  \item No persistent state
\end{itemize}

\subsection{Service Registration (Account Opening)}

\begin{itemize}
  \item Holder generates communication DID (persistent)
  \item Generates ZKP proving identity claims
  \item Issuer validates, creates account
  \item Issuer generates VC (e.g., account holder credential)
  \item Holder stores VC and communication DID-to-service association
  \item Later: Login reuses same communication DID
\end{itemize}

\subsection{Continuous Authentication (SNS, Messaging)}

\begin{itemize}
  \item Holder generates ephemeral communication DID per login
  \item Generates ZKP proving phone number ownership
  \item Service validates, establishes session
  \item Session token replaces ZKP for subsequent requests
  \item Communication DID may be stored for optional reconnection hint
\end{itemize}

\chapter{Formally Verifiable JSON Schema Subset}

\section{Abstract}

The AMATELUS protocol employs a formally verifiable subset of JSON Schema 2020-12 for Verifiable Credentials validation. This subset is specifically designed to enable formal verification in Lean 4 without axioms or partial definitions.

\section{Design Principles}

The JSON Schema subset is built on these principles:

\begin{itemize}
  \item \textbf{Formal Verification}: All features MUST be provably terminating in Lean 4
  \item \textbf{Protocol Guarantee}: Only features in this subset are guaranteed by AMATELUS protocol
  \item \textbf{Implementation Freedom}: Wallets MAY support full JSON Schema 2020-12 beyond protocol guarantees
  \item \textbf{Deterministic Validation}: Same schema produces identical results across all implementations
  \item \textbf{Future Evolution}: As Lean capability increases, subset expands toward full JSON Schema 2020-12
\end{itemize}

\section{Formalization Strategy}

\subsection{Why a Subset?}

Full JSON Schema 2020-12 includes features that prevent formal verification:

\begin{itemize}
  \item \textbf{Circular references} (via \texttt{\$ref}, \texttt{\$defs}): Cause non-termination
  \item \textbf{Dynamic property validation} (\texttt{additionalProperties}, \texttt{patternProperties}): Require unbounded iteration
  \item \textbf{Infinite nesting}: Composition keywords can nest arbitrarily
  \item \textbf{Format annotations}: Depend on external specifications
\end{itemize}

The subset eliminates these features to enable formal verification.

\subsection{Lean Formalization Structure}

\begin{verbatim}
inductive SchemaKeyword
  | type : List String → SchemaKeyword
  | maxLength : Nat → SchemaKeyword
  | minLength : Nat → SchemaKeyword
  | pattern : String → SchemaKeyword
  | maximum : Float → SchemaKeyword
  | minimum : Float → SchemaKeyword
  | multipleOf : Float → SchemaKeyword
  | maxItems : Nat → SchemaKeyword
  | minItems : Nat → SchemaKeyword
  | uniqueItems : Bool → SchemaKeyword
  | items : Schema → SchemaKeyword
  | maxProperties : Nat → SchemaKeyword
  | minProperties : Nat → SchemaKeyword
  | required : List String → SchemaKeyword
  | properties : List (String × Schema) → SchemaKeyword
  | enum : List JSONValue → SchemaKeyword
  | const : JSONValue → SchemaKeyword
  | allOf : List Schema → SchemaKeyword
  | anyOf : List Schema → SchemaKeyword
  | oneOf : List Schema → SchemaKeyword
  | not : Schema → SchemaKeyword
  | title : String → SchemaKeyword
  | description : String → SchemaKeyword
\end{verbatim}

Note: Excluded keywords like \texttt{\$ref}, \texttt{additionalProperties}, \texttt{format} are not in the inductive type.

\subsection{Termination Guarantee}

All supported features are \emph{provably terminating}:

\begin{enumerate}
  \item \textbf{No circular references}: \texttt{\$ref} excluded entirely
  \item \textbf{Bounded recursion}: Composition nesting limited to 3 levels
  \item \textbf{Finite structure}: All schemas have finite size
\end{enumerate}

\section{Supported Features}

The following JSON Schema keywords are \textbf{GUARANTEED} by AMATELUS protocol:

\subsection{Type System}

\begin{itemize}
  \item \textbf{\texttt{type}}: String or array of strings (null, boolean, object, array, number, string, integer)
\end{itemize}

\subsection{String Validation}

\begin{itemize}
  \item \textbf{\texttt{maxLength}}: Non-negative integer
  \item \textbf{\texttt{minLength}}: Non-negative integer
  \item \textbf{\texttt{pattern}}: ECMA-262 regular expression (abstracted in Lean)
\end{itemize}

\subsection{Numeric Validation}

\begin{itemize}
  \item \textbf{\texttt{maximum}}: Inclusive upper bound
  \item \textbf{\texttt{minimum}}: Inclusive lower bound
  \item \textbf{\texttt{multipleOf}}: Value must be multiple of given number
\end{itemize}

\subsection{Array Validation}

\begin{itemize}
  \item \textbf{\texttt{maxItems}}: Non-negative integer
  \item \textbf{\texttt{minItems}}: Non-negative integer
  \item \textbf{\texttt{uniqueItems}}: Boolean (default: false)
  \item \textbf{\texttt{items}}: Schema applied to all array items
\end{itemize}

\subsection{Object Validation}

\begin{itemize}
  \item \textbf{\texttt{maxProperties}}: Non-negative integer
  \item \textbf{\texttt{minProperties}}: Non-negative integer
  \item \textbf{\texttt{required}}: Array of unique property names that must exist
  \item \textbf{\texttt{properties}}: Object mapping property names to schemas
\end{itemize}

\subsection{Generic Validation}

\begin{itemize}
  \item \textbf{\texttt{enum}}: Non-empty array of allowed values
  \item \textbf{\texttt{const}}: Single fixed JSON value
\end{itemize}

\subsection{Schema Composition (Depth-Limited)}

\begin{itemize}
  \item \textbf{\texttt{allOf}}: Instance must validate against ALL subschemas (max 3 levels)
  \item \textbf{\texttt{anyOf}}: Instance must validate against AT LEAST ONE subschema (max 3 levels)
  \item \textbf{\texttt{oneOf}}: Instance must validate against EXACTLY ONE subschema (max 3 levels)
  \item \textbf{\texttt{not}}: Instance must NOT validate against subschema (max 3 levels)
\end{itemize}

\subsection{Annotation Keywords}

\begin{itemize}
  \item \textbf{\texttt{title}}: Human-readable title (informational only)
  \item \textbf{\texttt{description}}: Detailed description (informational only)
\end{itemize}

\section{Excluded Features}

The following JSON Schema features are \textbf{NOT GUARANTEED} at protocol level:

\subsection{Reference Keywords}

\begin{itemize}
  \item \textbf{\texttt{\$ref}}: Schema references (prevents termination proof)
  \item \textbf{\texttt{\$defs}}: Schema definitions (only useful with \texttt{\$ref})
  \item \textbf{\texttt{\$dynamicRef}}, \textbf{\texttt{\$dynamicAnchor}}: Dynamic references
\end{itemize}

\subsection{Dynamic Property Validation}

\begin{itemize}
  \item \textbf{\texttt{additionalProperties}}: Ignored at protocol level (wallets MAY validate)
  \item \textbf{\texttt{patternProperties}}: Not supported
  \item \textbf{\texttt{propertyNames}}: Not supported
  \item \textbf{\texttt{unevaluatedProperties}}, \textbf{\texttt{unevaluatedItems}}: Not supported
\end{itemize}

\subsection{Other Excluded Keywords}

\begin{itemize}
  \item \textbf{\texttt{if}}, \textbf{\texttt{then}}, \textbf{\texttt{else}}: Conditional schemas (use \texttt{oneOf} instead)
  \item \textbf{\texttt{prefixItems}}, \textbf{\texttt{contains}}: Advanced array features
  \item \textbf{\texttt{dependentRequired}}, \textbf{\texttt{dependentSchemas}}: Dependency keywords
  \item \textbf{\texttt{exclusiveMaximum}}, \textbf{\texttt{exclusiveMinimum}}: Exclusive bounds
  \item \textbf{\texttt{format}}: Format annotations (use \texttt{pattern} instead)
\end{itemize}

\section{Conformance Requirements}

\subsection{Conformant Schema}

A schema is AMATELUS-conformant if:

\begin{enumerate}
  \item Contains ONLY keywords from supported features
  \item Composition nesting does NOT exceed 3 levels
  \item \texttt{required} array contains unique strings
  \item \texttt{enum} array is non-empty
  \item Numeric constraints are valid numbers
  \item Size constraints are non-negative integers
  \item \texttt{multipleOf} is greater than 0
\end{enumerate}

\subsection{Conformant Validator}

An AMATELUS-conformant validator MUST:

\begin{enumerate}
  \item Validate all supported keywords correctly
  \item \textbf{Ignore} excluded keywords without error (e.g., \texttt{additionalProperties})
  \item Enforce nesting depth limit (3 levels)
  \item Produce deterministic results
  \item Reject schemas exceeding nesting limits
\end{enumerate}

\section{Future Evolution: Convergence Toward Full JSON Schema}

\subsection{Current Status}

This subset represents a \emph{formally verifiable foundation}. As Lean's formalization capabilities advance, the subset will gradually expand toward full JSON Schema 2020-12 compliance.

\subsection{Formalization-Driven Expansion}

The expansion strategy follows a principle: \textbf{expand the subset only as new features become provably terminating in Lean}.

\begin{itemize}
  \item \textbf{Lean 4 v1.0 onwards}: Recursive reference support (with termination metrics) may enable \texttt{\$ref} formalization
  \item \textbf{Future versions}: Advanced pattern matching and dependent types may enable:
    \begin{itemize}
      \item Dynamic property validation with bounded iteration proofs
      \item Conditional schema validation
      \item More complex nesting patterns
    \end{itemize}
  \item \textbf{Goal}: Eventually, full JSON Schema 2020-12 becomes formally verifiable
\end{itemize}

\subsection{Backward Compatibility}

\begin{itemize}
  \item Current AMATELUS-conformant schemas remain valid
  \item New features are only added when formally verified
  \item Protocol versioning ensures interoperability during transitions
  \item Wallets always free to support full JSON Schema 2020-12 beyond protocol guarantees
\end{itemize}

\subsection{Versioning Strategy}

\begin{verbatim}
AMATELUS JSON Schema Subset v1.0 (current)
- Formally verified features: 20+ keywords
- Excluded features: circular refs, dynamic validation, format

AMATELUS JSON Schema Subset v1.1 (hypothetical)
- New formalization: conditional validation via oneOf expansion
- Result: if/then/else pattern becomes recommended practice

AMATELUS JSON Schema Subset v2.0 (future)
- Lean capability: recursive references with termination proof
- Result: $ref support added with formal verification guarantees
\end{verbatim}

\section{Example: AMATELUS-Conformant VC Schema}

\begin{verbatim}
{
  "title": "Identity Credential",
  "type": "object",
  "properties": {
    "type": {
      "type": "string",
      "enum": ["IdentityCredential"]
    },
    "credentialSubject": {
      "type": "object",
      "properties": {
        "givenName": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100
        },
        "familyName": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100
        },
        "birthDate": {
          "type": "string",
          "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
        }
      },
      "required": ["givenName", "familyName"],
      "minProperties": 2,
      "maxProperties": 5
    }
  },
  "required": ["type", "credentialSubject"]
}
\end{verbatim}

\subsection{Why This Schema is Conformant}

\begin{itemize}
  \item Uses only supported keywords (\texttt{type}, \texttt{properties}, \texttt{required}, \texttt{enum}, \texttt{pattern})
  \item Nesting depth is 2 levels (within limit of 3)
  \item All constraints are valid (minLength, maxLength, minProperties, maxProperties)
  \item No circular references or dynamic validation
  \item Formally verifiable in Lean 4
\end{itemize}

\section{Security and Robustness}

\subsection{Validation Guarantees}

\begin{itemize}
  \item \textbf{Termination}: All schemas guaranteed to validate in finite time
  \item \textbf{Determinism}: Same input always produces identical output
  \item \textbf{No side effects}: Validation is pure computation
\end{itemize}

\subsection{Regular Expression Safety}

\begin{itemize}
  \item \textbf{ReDoS prevention}: Implementation SHOULD enforce regex timeout limits
  \item \textbf{Abstraction in Lean}: Regex matching abstracted as \texttt{MatchedString}/\texttt{UnmatchedString}
  \item \textbf{Implementation responsibility}: Wallet implementations must validate regex syntax
\end{itemize}

\subsection{Schema Complexity Limits}

\begin{itemize}
  \item \textbf{Max nesting}: 3 levels prevents deeply nested schemas
  \item \textbf{Max properties}: No explicit limit, but implementations MAY enforce reasonable bounds
  \item \textbf{No recursion}: Eliminates infinite loops and stack overflow risks
\end{itemize}

\chapter{Trust Chain Architecture}

\section{Overview}

The Trust Chain specification provides a hierarchical delegation mechanism that enables authority transfer through cryptographically verified credentials. Key capabilities include:

\begin{itemize}
  \item \textbf{Authority Delegation}: Upper organizations delegate authority to lower organizations
  \item \textbf{Cryptographic Verification}: Delegation chains are cryptographically verifiable
  \item \textbf{Schema-Based Delegation}: Delegation content is structurally defined using JSON Schema
  \item \textbf{Dynamic Depth Limitation}: Delegators specify \texttt{maxDepth}; Nat monotonic decrease prevents infinite hierarchies
  \item \textbf{Holder-Centric Design}: VCs can be issued by anyone (including Holders themselves); verifiers check only the delegation chain's \texttt{grantorDID}
  \item \textbf{Per-Claim Signatures}: Recipients sign each claim individually, dramatically reducing VP/ZKP input sizes
  \item \textbf{ZKP-Only Submission}: VPs are internal structures; all submissions use only ZKPs
  \item \textbf{Field-Level Selective Disclosure}: ZKPs enable revelation of only required fields, maximizing privacy
\end{itemize}

\section{Trust Chain Components}

\subsection{Architecture}

A trust chain flows from a root authority through delegatees to holders:

\begin{center}
\begin{verbatim}
Root Anchor (Trusted Authority)
    ↓ Delegation Credential
    │ (delegated authority → recipient)
    ↓
Delegatee (Authority)
    ↓ Attribute Credential
    │ (claim with embedded delegation)
    ↓
Holder (Subject)
    ↓ Re-packaging (optional)
    │ (Holder re-issues with own signature)
    ↓
Verifier (Service Provider)
    verifies:
    - ZKP validity
    - grantorDID in trustedAnchors
    does NOT verify:
    - VC issuer
    - granteeDID matching
\end{verbatim}
\end{center}

\subsection{Critical Design Principles}

\begin{itemize}
  \item \textbf{VC Issuer Flexibility}: The \texttt{issuer} field can be anyone; trust derives from the delegation chain's \texttt{grantorDID}
  \item \textbf{Delegation Chain Focus}: Verifiers inspect \texttt{grantorDID} (trust root), not \texttt{issuer}
  \item \textbf{ZKP Compatibility}: VCs issued by Holders can still prove delegated authority via ZKP
  \item \textbf{Holder Re-packaging}: Holders can re-issue received VCs with their own signature; each claim's proof remains unchanged
\end{itemize}

\section{Delegation Credentials}

\subsection{Structure}

A Delegation Credential contains multiple delegations, each authorizing a specific claim type:

\begin{itemize}
  \item \textbf{issuer}: Delegator's DID (must be in \texttt{trustedAnchors})
  \item \textbf{credentialSubject.id}: Original recipient's DID (historical information)
  \item \textbf{credentialSubject.delegations}: Array of delegation objects
  \item \textbf{proof}: Delegator's signature over the entire credential
\end{itemize}

Each delegation element contains:

\begin{itemize}
  \item \textbf{grantorDID}: Authority granting the right (verification anchor)
  \item \textbf{granteeDID}: Initial recipient DID (historical information)
  \item \textbf{label}: Human-readable claim label (e.g., ``Resident Certificate'')
  \item \textbf{claimSchema}: JSON Schema (AMATELUS Subset) defining allowed claim structure
  \item \textbf{maxDepth}: Maximum further delegation depth (Nat $\geq 1$)
  \item \textbf{proof}: Delegator's signature over the delegation object
\end{itemize}

\subsection{Dynamic Depth Limitation}

The protocol prevents infinite delegation chains through monotonic depth decrease:

\begin{enumerate}
  \item Each delegator specifies \texttt{maxDepth} (maximum delegations from this point forward)
  \item Each recipient computes: \texttt{nextDepth = min(parentDepth - 1, delegation.maxDepth)}
  \item When depth reaches zero, further delegation is impossible
  \item Lean 4 formally proves termination via \texttt{termination\_by} clause
\end{enumerate}

Example: Government $\xrightarrow{\text{maxDepth}=5}$ Prefecture $\xrightarrow{\text{maxDepth}=2}$ Municipality $\xrightarrow{\text{maxDepth}=1}$ Department $\xrightarrow{\text{maxDepth}=0}$ (chain stops)

\section{Attribute Credentials with Embedded Delegation}

\subsection{Direct Issuance (0-Layer)}

Standard W3C VC issued directly by a trusted authority:

\begin{itemize}
  \item No delegation chain
  \item Simple structure: \texttt{issuer}, \texttt{credentialSubject.claims}, \texttt{proof}
  \item Verification: \texttt{issuer} must be in \texttt{trustedAnchors}
\end{itemize}

\subsection{Delegated Issuance (1-Layer and Beyond)}

When issued under delegated authority, each claim embeds delegation information:

\begin{itemize}
  \item \textbf{content}: Actual claim data
  \item \textbf{delegation}: Reference to the delegation authorization
  \item \textbf{delegationProof}: Grantor's signature over the delegation
  \item \textbf{proof}: Grantee's signature over the content (prevents Holder modification)
\end{itemize}

Verification checks:
\begin{enumerate}
  \item \texttt{delegation.grantorDID} is in \texttt{trustedAnchors}
  \item \texttt{content} conforms to \texttt{delegation.claimSchema}
  \item \texttt{delegationProof} is valid under \texttt{grantorDID}
  \item \texttt{proof} is valid under \texttt{granteeDID} (enables ZKP verification)
\end{enumerate}

Does \textbf{NOT} verify:
\begin{itemize}
  \item VC's \texttt{issuer} field (can be anyone, including the Holder)
  \item \texttt{granteeDID} matches VC's \texttt{issuer}
\end{itemize}

\subsection{Holder Re-Packaging}

Holders can re-issue received VCs under their own DID:

\begin{itemize}
  \item VC's \texttt{issuer} becomes Holder's DID
  \item VC's \texttt{proof} becomes Holder's signature
  \item Each claim's \texttt{content}, \texttt{delegation}, \texttt{delegationProof}, \texttt{proof} remain unchanged
  \item Verification remains unchanged (still trusts \texttt{grantorDID})
\end{itemize}

This enables Holders to maintain privacy from service providers while proving delegated authority through ZKP.

\section{Verifiable Presentations and ZKP Generation}

\subsection{VP as Internal Structure}

Unlike W3C specifications, AMATELUS uses VPs internally only:

\begin{itemize}
  \item VPs are \textbf{never submitted directly} to issuers or verifiers
  \item VPs serve to organize claims before ZKP generation
  \item Holders extract only required claims from multiple VCs and assemble them into a VP
  \item ZKP is generated from the VP's selected claims, not the original VCs
\end{itemize}

\subsection{ZKP Input Size Reduction}

This design dramatically reduces computational cost:

\begin{itemize}
  \item \textbf{Traditional method}: ZKP includes all claims from all VCs
  \item \textbf{VP+Individual Signatures method}: ZKP includes only selected claims
  \item \textbf{Efficiency gain}: If Holder needs 3 claims from 23 total, ZKP input shrinks to $\approx 1/8$
  \item \textbf{Mobile impact}: Battery consumption, memory use, and response time all improve proportionally
\end{itemize}

Each claim's individual \texttt{proof} (recipient's signature) enables this efficiency:

\begin{itemize}
  \item Allows claims to be verified independently
  \item Prevents Holder from modifying claim content (signature would fail)
  \item Enables selective disclosure without revealing unneeded claims
\end{itemize}

\subsection{Submission to Issuers}

When requesting a new VC from an issuer:

\begin{enumerate}
  \item Holder creates a VP (internal only) from relevant credentials
  \item Holder generates a ZKP with public inputs including:
    \begin{itemize}
      \item Holder's DID (issuer needs to record who is requesting)
      \item Required fields (e.g., name, age category, income threshold proof)
      \item \texttt{grantorDIDs} (proof authorities)
    \end{itemize}
  \item Holder submits: \texttt{\{zkp, publicInputs\}} only
  \item Issuer verifies ZKP and creates new VC with \texttt{credentialSubject.id} from public input
\end{enumerate}

\subsection{Submission to Verifiers}

When proving attributes to a service provider:

\begin{enumerate}
  \item Holder creates a VP (internal only) from relevant credentials
  \item Holder generates a ZKP with public inputs including:
    \begin{itemize}
      \item Required properties only (e.g., ``age $\geq 20'', ``residence in Japan'')
      \item Holder's DID is \textbf{hidden} in ZKP's secret inputs
      \item \texttt{grantorDIDs} (proof authorities)
    \end{itemize}
  \item Holder submits: \texttt{\{zkp, publicInputs\}} only
  \item Verifier verifies ZKP without learning:
    \begin{itemize}
      \item Holder's identity (DID)
      \item Specific personal information (exact birthdate, address, etc.)
      \item Which claims or VCs were used
      \item Original credential content
    \end{itemize}
\end{enumerate}

This achieves complete privacy for cross-service authentication: the verifier learns only what is cryptographically necessary.

\section{Security Properties}

\subsection{Depth Limitation Proofs}

Lean 4 formally proves three key properties:

\begin{enumerate}
  \item \textbf{Termination}: \texttt{verifyChain} always completes in finite time (via \texttt{termination\_by remainingDepth})
  \item \textbf{Finite Chain Length}: No valid chain can exceed \texttt{initialMaxDepth}
  \item \textbf{N-Layer Finiteness}: Multi-layer delegations remain bounded
\end{enumerate}

\subsection{Circular Delegation Prevention}

DIDs in a chain must be unique (O(n) check):

\begin{itemize}
  \item Detects cycles by comparing \texttt{getAllDIDs(chain)} with \texttt{getAllDIDs(chain).eraseDups}
  \item \texttt{verifyChain} returns false if duplicates found
\end{itemize}

\subsection{Holder-Centric Verification}

By focusing verification on \texttt{grantorDID} rather than \texttt{issuer}:

\begin{itemize}
  \item \textbf{Issuer Independence}: Credentials can be re-issued by different parties without verification failure
  \item \textbf{Holder Privacy}: Holders can re-package credentials under their own DID without disclosure
  \item \textbf{ZKP Compatibility}: Delegation authority persists even when issuer is hidden via ZKP
\end{itemize}

\subsection{Per-Claim Signature Guarantees}

Each claim's \texttt{proof} (recipient's signature):

\begin{itemize}
  \item Prevents Holders from modifying claim content
  \item Enables independent claim verification (critical for VP-based ZKP generation)
  \item Survives Holder re-packaging (signature remains unchanged)
\end{itemize}

\section{Examples}

\subsection{Single-Layer Delegation}

Government delegates ``Resident Certificate'' authority to municipalities:

\begin{center}
\begin{verbatim}
Government (grantorDID)
  ↓ Delegation Credential
    (grants Resident Certificate authority)
    maxDepth = 1
  ↓
Municipality (granteeDID)
  ↓ Attribute Credential
    (issues resident data with embedded delegation)
  ↓
Resident (Holder)
  ↓ Requests Bank Account
    (verifier: Bank)
  ↓
Bank
  - Verifies ZKP
  - Confirms government DID in trustedAnchors
  - Approves account
\end{verbatim}
\end{center}

\subsection{Multi-Layer Delegation with Holder Privacy}

\begin{center}
\begin{verbatim}
Government (grantorDID, maxDepth=3)
  ↓ Prefecture (maxDepth=2)
  ↓ Municipality (maxDepth=1)
  ↓ Resident (Holder, issues self-signed VC)
  ↓ Applies for Job
    (submits ZKP: age≥18, no criminal record)
  ↓
Employer (Verifier)
  - Verifies ZKP
  - Does NOT learn:
    - Resident's identity
    - Exact age/birthdate
    - Criminal history status
    - Original credentials
  - Learns only:
    - Age threshold met
    - Background check passed
    - Government issued proof
\end{verbatim}
\end{center}

\chapter{Conclusion}

AMATELUS provides a clean separation of concerns:

\begin{itemize}
  \item \textbf{Cryptographic layer}: AMATELUS ensures authentication and privacy
  \item \textbf{Service layer}: Service providers ensure authorization and delivery
  \item \textbf{User layer}: Users choose which services and DIDs to use
\end{itemize}

This architecture achieves:
\begin{itemize}
  \item \textbf{Security}: Formal cryptographic guarantees
  \item \textbf{Scalability}: Linear throughput with users
  \item \textbf{Privacy}: Cross-service unlinkability
  \item \textbf{Simplicity}: Clear responsibility boundaries
  \item \textbf{Practicality}: No distributed infrastructure burden on users
\end{itemize}

The protocol enables centralized services to provide decentralized authentication—a pragmatic foundation for digital governance in the real world.
