\chapter{Merkle Tree Revocation}


\begin{definition}
  \label{def:revoke-chapter}
  This chapter covers merkle tree revocation aspects of AMATELUS.
  \uses{def:amatelus,def:crypto-assumptions}
  \lean{AMATELUS.Revocation}
  \leanok
\end{definition}
\section{Abstract}

This chapter defines the detailed specification of \textbf{Merkle Tree-based revocation verification flow} in the AMATELUS protocol. Unlike W3C Bitstring Status List which reveals credential identification information, the Merkle Tree approach preserves zero-knowledge properties.

\section{Background and Motivation}

\subsection{Problem with Bitstring Status List}

W3C Bitstring Status List requires public disclosure of \texttt{statusListIndex}, creating a fundamental contradiction with Zero-Knowledge Proofs:

\begin{verbatim}
Traditional approach (Bitstring Status List):
  Holder -> statusListIndex -> Issuer

  Problems:
  - statusListIndex disclosure = credential identification
  - ZKP zero-knowledge property collapses
  - Privacy protection impossible
\end{verbatim}

\subsection{Design Goals}

This specification achieves:

\begin{enumerate}
  \item \textbf{Zero-Knowledge Preservation}: Specific credential presentation never identified
  \item \textbf{Revocation Safety}: Revoked VCs cannot generate ZKPs
  \item \textbf{Scalability}: O(log N) computation (N = active VC count)
  \item \textbf{Disaster Availability}: Revocation check skippable offline
  \item \textbf{W3C VC Compatibility}: Implemented as credentialStatus extension
  \item \textbf{Personal Issuer Support}: Non-server-managing issuers can operate
\end{enumerate}

\subsection{Personal Issuer Challenge and Solution}

\subsubsection{Challenge}

Merkle Tree revocation requires issuers to operate centralized web servers (for Merkle Root publication):

\begin{verbatim}
Problems:
  - Personal issuers may not maintain 24/7 HTTP servers
  - Server management costs (domain, SSL, infrastructure)
  - Difficulty guaranteeing constant availability
\end{verbatim}

\subsubsection{Solution: revocationEnabled Flag}

\textbf{Design Principle}:

\begin{verbatim}
Issuers include revocation capability at issuance time
  down arrow
Holders input this flag during ZKP generation
  down arrow
Verifiers can mathematically determine revocation status
\end{verbatim}

\textbf{Implementation}:

\begin{enumerate}
  \item Issuer includes \texttt{revocationEnabled: true/false} in claims at issuance
  \item This flag is under issuer signature (tamper-proof)
  \item ZKP circuit verifies:
    \begin{itemize}
      \item \texttt{revocationEnabled = true} requires Merkle proof verification
      \item \texttt{revocationEnabled = false} skips Merkle proof verification
    \end{itemize}
  \item Verifier receives \texttt{revocationEnabled} in public ZKP inputs
\end{enumerate}

\textbf{Benefits}:

\begin{itemize}
  \item Personal issuers require no server management (\texttt{revocationEnabled = false})
  \item Verifiers mathematically confirm revocation status (Holder cannot hide)
  \item Organizational issuers provide high trust (\texttt{revocationEnabled = true})
\end{itemize}

\section{Architecture Overview}

\subsection{Overall Flow}

\begin{verbatim}
┌─────────────────────┐
│   Issuer            │
│                     │
│  1. Issue VC        │
│  2. Manage Active List│
│     [H(VC_1), H(VC_2), ...] │
│  3. Generate Merkle Root │
│     root = H(...)   │
│  4. Publish Root (signed) │
└──────────┬──────────┘
           │
           │ Merkle Root + Signature
           │ (updated hourly)
           down arrow
┌─────────────────────┐
│   Holder            │
│                     │
│  1. Fetch Merkle Root │
│  2. Generate Merkle Proof │
│     proof = [h_1, h_2, ...] │
│  3. Generate ZKP    │
│     - VC content (secret) │
│     - Merkle proof (secret) │
│     - Merkle Root (public) │
└──────────┬──────────┘
           │
           │ ZKP + Merkle Root
           │
           down arrow
┌─────────────────────┐
│   Verifier          │
│                     │
│  1. Verify Merkle Root │
│     - Check issuer signature │
│  2. Verify timestamp │
│     - Check validUntil (issuer-signed) │
│     - Check version │
│  3. Verify ZKP      │
│     - Verify Merkle proof in circuit │
│     - VC in Active List? -> OK │
│     - VC not in list? -> NG │
└─────────────────────┘
\end{verbatim}

\subsection{Data Structures}

\subsubsection{Merkle Revocation List}

Information managed by issuer:

\begin{verbatim}
structure MerkleRevocationList where
  activeVCHashes : List Hash
  merkleRoot : Hash
  updatedAt : Timestamp
  validUntil : Timestamp
  version : Nat
  issuerSignature : Signature
\end{verbatim}

\subsubsection{Merkle Proof}

Inclusion proof generated by holder:

\begin{verbatim}
structure MerkleProof where
  leafIndex : Nat
  siblingHashes : List Hash
  treeDepth : Nat
\end{verbatim}

\subsubsection{ZKP Inputs with Revocation}

\textbf{Secret Inputs}:

\begin{verbatim}
structure ZKPSecretInputWithRevocation where
  vcContent : String
  issuerSignature : Signature
  merkleProof : Option MerkleProof
  additionalSecrets : List (String * String)
\end{verbatim}

\textbf{Public Inputs}:

\begin{verbatim}
structure ZKPPublicInputWithRevocation where
  revocationEnabled : Bool
  merkleRoot : Option Hash
  merkleRootVersion : Option Nat
  publicAttributes : List (String * String)
  verifierNonce : Nonce
  holderNonce : Nonce
\end{verbatim}

\section{Merkle Tree Construction}

\subsection{Hash Function}

\begin{itemize}
  \item \textbf{SHA-256}: Merkle Tree construction (ZKP circuit compatible)
  \item \textbf{SHA3-512}: Other purposes (quantum safe)
\end{itemize}

\subsection{Tree Construction Algorithm}

\begin{verbatim}
Input: activeVCHashes = [h_1, h_2, ..., h_n]
Output: merkleRoot

Algorithm:
  1. Padding (adjust to power of 2)
     if n not power of 2:
       pad with H("") until next power of 2

  2. Level 0 (leaves)
     leaves = activeVCHashes + padding

  3. Upward computation
     while len(leaves) > 1:
       new_level = []
       for i in range(0, len(leaves), 2):
         parent = SHA-256(leaves[i] || leaves[i+1])
         new_level.append(parent)
       leaves = new_level

  4. Return root
     return leaves[0]
\end{verbatim}

\subsection{Merkle Proof Generation}

\begin{verbatim}
Input:
  - vcHash (VC to prove)
  - activeVCHashes (all active VCs)
  - merkleRoot (for verification)

Output: MerkleProof

Algorithm:
  1. Find VC position
     leafIndex = activeVCHashes.indexOf(vcHash)
     if leafIndex == -1: return None

  2. Collect proof path
     siblingHashes = []
     currentIndex = leafIndex
     currentLevel = activeVCHashes + padding

     while len(currentLevel) > 1:
       siblingIndex = currentIndex XOR 1
       siblingHashes.append(currentLevel[siblingIndex])
       currentIndex = currentIndex / 2
       currentLevel = computeParentLevel(currentLevel)

  3. Return proof
     return MerkleProof {
       leafIndex,
       siblingHashes,
       treeDepth = log_2(len(activeVCHashes))
     }
\end{verbatim}

\subsection{Merkle Proof Verification}

\begin{verbatim}
Input:
  - vcHash (VC to verify)
  - proof (MerkleProof)
  - merkleRoot (expected root)

Output: Bool

Algorithm:
  1. Start from leaf
     currentHash = vcHash
     currentIndex = proof.leafIndex

  2. Compute to root
     for siblingHash in proof.siblingHashes:
       if currentIndex % 2 == 0:
         currentHash = SHA-256(currentHash || siblingHash)
       else:
         currentHash = SHA-256(siblingHash || currentHash)
       currentIndex = currentIndex / 2

  3. Compare with root
     return currentHash == merkleRoot
\end{verbatim}

\section{ZKP Circuit Integration}

\subsection{Circuit Constraints}

\textbf{Public Inputs}:

\begin{verbatim}
- revocation_enabled (enablement flag from VC claim)
- merkle_root (latest, if revocation_enabled = true)
- merkle_root_version (version, if revocation_enabled = true)
- claimed_attributes (age >= 20, etc.)
- verifier_nonce
- holder_nonce
\end{verbatim}

\textbf{Private Inputs}:

\begin{verbatim}
- vc_full (complete VC content)
- issuer_signature (VC signature from issuer)
- merkle_proof.leafIndex (if revocation_enabled = true)
- merkle_proof.siblingHashes (if revocation_enabled = true)
- merkle_proof.treeDepth (if revocation_enabled = true)
\end{verbatim}

\textbf{Constraints}:

\begin{enumerate}
  \item Verify issuer signature
  \item Extract and match revocationEnabled flag from VC
  \item Compute VC hash: \texttt{vc\_hash = SHA-256(Canonicalize(vc\_full))}
  \item If \texttt{revocation\_enabled = true}: Verify Merkle proof matches \texttt{merkle\_root}
  \item If \texttt{revocation\_enabled = false}: Skip Merkle proof verification
  \item Verify selective attribute disclosure
  \item Verify nonce binding: \texttt{nonce\_combined = SHA-256(holder\_nonce || verifier\_nonce)}
\end{enumerate}

\section{Issuer Operations}

\subsection{VC Issuance}

\subsubsection{With Revocation Enabled}

For organizational issuers with server infrastructure:

\begin{enumerate}
  \item Generate VC with \texttt{revocationEnabled: true}
  \item Compute VC hash
  \item Add to Active List
  \item Generate Merkle Root
  \item Publish signed Merkle Root with \texttt{validUntil}
  \item Send VC + Merkle Proof to Holder
\end{enumerate}

\subsubsection{With Revocation Disabled}

For personal issuers without servers:

\begin{enumerate}
  \item Generate VC with \texttt{revocationEnabled: false}
  \item Skip all Merkle operations
  \item Send VC to Holder only
\end{enumerate}

\subsection{VC Revocation}

For \texttt{revocationEnabled = true} credentials:

\begin{enumerate}
  \item Receive revocation request from Holder
  \item Compute VC hash
  \item Remove from Active List
  \item Generate new Merkle Root
  \item Publish signed with new version
  \item Log revocation for audit
\end{enumerate}

For \texttt{revocationEnabled = false} credentials:

\begin{itemize}
  \item No revocation mechanism exists
  \item Request holder to discard credential
  \item Or issue replacement with \texttt{revocationEnabled = true}
\end{itemize}

\subsection{Periodic Merkle Root Updates}

Execute hourly (Cron Job):

\begin{enumerate}
  \item Load current Active List
  \item Recompute Merkle Root
  \item Increment version number
  \item Set \texttt{validUntil = now() + 1 hour}
  \item Sign: \texttt{issuerSignature = Sign(merkleRoot || version || validUntil)}
  \item Publish
\end{enumerate}

\section{Holder Operations}

\subsection{ZKP Generation with Revocation}

\subsubsection{When revocationEnabled = true}

\begin{enumerate}
  \item Extract \texttt{revocationEnabled} flag from VC
  \item Fetch latest Merkle Root (verify issuer signature)
  \item Verify Merkle Root expiration (\texttt{validUntil})
  \item Verify Merkle Proof locally
  \item Generate holder nonce
  \item Prepare ZKP secret inputs (include Merkle Proof)
  \item Prepare ZKP public inputs (include merkleRoot, merkleRootVersion)
  \item Generate ZKP
  \item Return ZKP + revocationEnabled flag + merkleRoot + version + nonce
\end{enumerate}

\subsubsection{When revocationEnabled = false}

\begin{enumerate}
  \item Extract \texttt{revocationEnabled} flag from VC
  \item Skip Merkle Root fetch
  \item Skip Merkle Proof generation
  \item Generate holder nonce
  \item Prepare ZKP secret inputs (no Merkle Proof)
  \item Prepare ZKP public inputs (no merkleRoot, merkleRootVersion)
  \item Generate ZKP
  \item Return ZKP + revocationEnabled flag + nonce
\end{enumerate}

\section{Verifier Operations}

\subsection{ZKP Verification with Revocation}

\subsubsection{When revocationEnabled = true}

\begin{enumerate}
  \item Fetch latest Merkle Root from issuer
  \item Verify issuer signature on Merkle Root
  \item Fetch historical Merkle Root (by version) used by holder
  \item Verify issuer signature on historical root
  \item Verify timestamp: \texttt{now() <= validUntil}
  \item Verify version lag (e.g., MAX\_VERSION\_LAG = 5)
  \item Verify Merkle Root matches
  \item Verify ZKP with public inputs (\texttt{revocationEnabled = true}, \texttt{merkleRoot}, \texttt{merkleRootVersion})
  \item Verify nonce uniqueness (prevent replay)
  \item Accept if all checks pass
\end{enumerate}

\subsubsection{When revocationEnabled = false}

\begin{enumerate}
  \item Check verifier policy (accept non-revocable VCs?)
  \item If rejected by policy, return False
  \item Verify ZKP with public inputs (\texttt{revocationEnabled = false}, no merkleRoot)
  \item Verify nonce uniqueness
  \item Log warning (revocation check skipped)
  \item Accept if policy allows
\end{enumerate}

\subsection{Offline Verification Mode}

During disasters when issuer server unavailable:

\begin{enumerate}
  \item Use cached issuer public key
  \item Verify ZKP without revocation check
  \item Log warning (offline mode)
  \item Accept if previous successful verification logged
\end{enumerate}

\section{W3C VC Integration}

\subsection{credentialStatus Extension}

\subsubsection{With Revocation Enabled}

\begin{verbatim}
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://amatelus.example/context/revocation/v1"
  ],
  "credentialStatus": {
    "id": "https://issuer.example/status/merkle/v1",
    "type": "MerkleTreeRevocationList2024",
    "merkleRootEndpoint": "https://issuer.example/api/merkle-root",
    "merkleProofEndpoint": "https://issuer.example/api/merkle-proof",
    "vcHash": "0x1234567890abcdef..."
  },
  "credentialSubject": {
    "revocationEnabled": true,
    ...
  }
}
\end{verbatim}

\subsubsection{With Revocation Disabled}

\begin{verbatim}
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2"
  ],
  "credentialSubject": {
    "revocationEnabled": false,
    ...
  }
  // no credentialStatus field
}
\end{verbatim}

\section{Security Analysis}

\subsection{Zero-Knowledge Guarantee}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{VC Identifiable?} & \textbf{Information Leaked} & \textbf{ZK Property} \\
\hline
Bitstring Status List & Yes & statusListIndex & No \\
\hline
Merkle Tree & No & merkleRoot only & Yes \\
\hline
\end{tabular}
\end{table}

\textbf{Proof}: Verifier receives only \texttt{merkleRoot} (hash of all active VCs). No information identifies specific VC. Merkle proof path remains secret in ZKP circuit.

\subsection{Revocation Safety}

\textbf{Theorem (Formal Verification)}: When VC is revoked:

\begin{enumerate}
  \item \texttt{activeVCHashes} no longer contains \texttt{vc\_hash}
  \item New \texttt{merkleRoot} generated without \texttt{vc\_hash}
  \item Holder attempts ZKP generation with revoked VC
  \item Merkle proof verification fails in ZKP circuit
  \item ZKP generation fails
  \item Mathematical guarantee: revoked VCs cannot generate valid ZKPs
\end{enumerate}

\subsection{Timestamp Forgery Resistance}

\textbf{Problem}: ZKP circuit cannot safely verify timestamps (holder controls time input)

\textbf{Solution}: Verifier-side verification with issuer signature

\begin{verbatim}
issuerSignature = Sign(merkleRoot || version || validUntil)

Verifier verification:
  1. Verify(issuerSignature, issuer_pubkey) = True
  2. now() <= validUntil

Guarantee:
  - Holder cannot forge timestamp (requires issuer private key)
  - Old merkleRoot (before revocation) cannot be used
  - Dilithium2 signature forgery requires 2^128 operations
\end{verbatim}

\subsection{Replay Attack Resistance}

\textbf{Dual-Nonce Mechanism}:

\begin{verbatim}
nonce_combined = SHA-256(holder_nonce || verifier_nonce)

Protection:
- If holder's nonce generation bugs: verifier's nonce randomness protects
- If verifier's nonce generation bugs: holder's nonce randomness protects
- Replay: old nonces recorded, duplicates rejected
\end{verbatim}

\section{Computational Complexity}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Operation} & \textbf{Complexity} & \textbf{Example (N=1M)} \\
\hline
Merkle Tree Construction & O(N) & 1M hash operations \\
\hline
Merkle Proof Generation & O(log N) & 20 hash operations \\
\hline
Merkle Proof Verification & O(log N) & 20 hash operations \\
\hline
ZKP Circuit Verification & O(log N) & 20 SHA-256 ops \\
\hline
\end{tabular}
\end{table}

\textbf{Scalability}: 100 million active VCs produces Merkle proof depth = 27, requiring 27 SHA-256 computations in ZKP circuit (practical).

\section{Implementation Checklist}

\subsection{Issuer Requirements}

\begin{itemize}
  \item Active VC list database design
  \item Merkle Tree library (SHA-256)
  \item Hourly update Cron Job
  \item API Endpoints: \texttt{GET /api/merkle-root}, \texttt{GET /api/merkle-proof}, \texttt{POST /api/revoke}
  \item Issuer private key management (HSM recommended)
  \item Revocation audit logging
  \item Store multiple Merkle Root versions (latest 5+)
\end{itemize}

\subsection{Holder Requirements}

\begin{itemize}
  \item Merkle Root fetch logic
  \item Merkle proof generation/verification
  \item ZKP circuit integration (SHA-256, issuer signature verification, attribute extraction)
  \item Background precomputation management
  \item Offline mode support
  \item Error handling (revocation notification)
\end{itemize}

\subsection{Verifier Requirements}

\begin{itemize}
  \item Issuer public key retrieval and verification
  \item Merkle Root fetch and signature verification
  \item ZKP verification library
  \item Nonce management (replay prevention)
  \item Timestamp verification
  \item Offline mode support (optional)
  \item Audit logging
\end{itemize}

\section{Conclusion}

This Merkle Tree revocation mechanism solves the fundamental contradiction between Verifiable Credentials' privacy requirements and revocation safety:

\begin{enumerate}
  \item \textbf{Zero-Knowledge Preservation}: Unlike Bitstring Status List
  \item \textbf{Revocation Guarantee}: Mathematical certainty that revoked VCs cannot generate ZKPs
  \item \textbf{Timestamp Security}: Issuer signature prevents Holder timestamp forgery
  \item \textbf{Scalability}: O(log N) logarithmic complexity
  \item \textbf{Personal Issuer Support}: No server infrastructure required (revocationEnabled = false)
  \item \textbf{Disaster Tolerance}: Offline verification possible
  \item \textbf{W3C Compatible}: Standard credentialStatus extension
\end{enumerate}

The core innovation is the \textbf{revocationEnabled flag}, which enables:
- Mathematical determination of revocation capability
- Support for personal issuers (no server required)
- Verifier policy enforcement (accept or reject non-revocable credentials)
- Complete accountability (Holder cannot hide revocation status from Verifier)
